1. User-defined functions
Welcome to the course! My name is Hugo Bowne-Anderson and I am a Data Scientist at DataCamp. In this course, the first of the Python Data Science Toolbox courses, you'll learn to write your very own functions and you'll have the opportunity to apply these newfound skills to questions that commonly arise in Data Science contexts.

2. Youâ€™ll learn:
Specifically, in this video and in the interactive exercises that follow it, you will learn to do the following: define functions without parameters, define functions with single parameters, and define functions that return a single value. In the next section, you'll learn how to pass multiple arguments to functions, as well as return multiple values from them. Let's begin!

3. Built-in functions
Let's check out Python's built-in function str, which accepts an object such as a number and returns a string object. You can assign a call to str to a variable to store its return value. While built-in Python functions are cool, as a Data Scientist, you'll need functions that have functionality specific to your needs. Fortunately, you can define your own functions in Python!

4. Defining a function
We'll now see how to define functions via an example, a function that squares a number. The function name square will be perfect for this. To define the function, We begin with the keyword def, followed by the function name square; this is then followed by a set of parentheses and a colon. This piece of code is called a function header. To complete the function definition, let's write the function body by squaring a value, say 4, and printing the output. Right now, our square function does not have any parameters within the parentheses. We will add them later. Now, whenever this function is called, the code in the function body is run. In this case, new_value is assigned the value of 4 ** 2 and then printed out. You can call the function as you do with pre-built functions: square. This should yield the value, 16.

5. Function parameters
What if you wanted to square any other number besides 4, though? To add that functionality, you add a parameter to the function definition in between the parentheses. Here you see that we've added a parameter value and in the new function body, the variable new_value takes the square of value, which is then printed out. We can now square any number that we pass to the function square as an argument. A quick word on parameters and arguments: when you define a function, you write parameters in the function header. When you call a function, you pass arguments into the function.

6. Return values from functions
The function square now accepts a single parameter and prints out its squared value. But what if we don't want to print that value directly and instead we want to return the squared value and assign it to some variable? You can have your function return the new value by adding the return keyword, followed by the value to return. Now we can assign to a variable num the result of the function call as you see here.

7. Docstrings
There's another essential aspect of writing functions in Python: docstrings. Docstrings are used to describe what your function does, such as the computations it performs or its return values. These descriptions serve as documentation for your function so that anyone who reads your function's docstring understands what your function does, without having to trace through all the code in the function definition. Function docstrings are placed in the immediate line after the function header and are placed in between triple quotation marks. An appropriate Docstring for our function square is 'Returns the square of a value'.

8. Let's practice!
You've now just learned the basics of defining your own functions! Now it's your turn. In the next few exercises, you will try your hand at defining and using your own functions.